import * as fs from "fs";
import * as path from "path";
import prettier from "prettier";

interface DeploymentData {
  address: string;
  receipt: {
    blockNumber: number;
  };
  abi: any[];
}

async function generatePonderConfig() {
  const deploymentsDir = "./deployments";
  const ponderPath = "../ponder";
  const ponderConfigPath = path.join(ponderPath, "src/config/chains.ts");
  const ponderAbisPath = path.join(ponderPath, "abis");

  // Create necessary directories
  if (!fs.existsSync(path.join(ponderPath, "src/config"))) {
    fs.mkdirSync(path.join(ponderPath, "src/config"), { recursive: true });
  }
  if (!fs.existsSync(ponderAbisPath)) {
    fs.mkdirSync(ponderAbisPath, { recursive: true });
  }

  const chains: Record<string, any> = {};
  const ethSplitterContracts: Record<string, any> = {};

  // Chain ID to name mapping - standard for Scaffold-ETH projects
  const chainIdToName: Record<string, string> = {
    "1": "mainnet",
    "137": "polygon",
    "42161": "arbitrum",
    "10": "optimism",
    "8453": "base",
    "84532": "baseSepolia",
    "11155420": "optimismSepolia",
    "534352": "scroll",
    "31337": "localhost",
    "11155111": "sepolia",
  };

  // Chain RPC URLs - using Alchemy and public endpoints
  const chainRpcUrls: Record<string, string> = {
    mainnet: `https://eth-mainnet.g.alchemy.com/v2/`,
    polygon: `https://polygon-mainnet.g.alchemy.com/v2/`,
    arbitrum: `https://arb-mainnet.g.alchemy.com/v2/`,
    optimism: `https://opt-mainnet.g.alchemy.com/v2/`,
    base: `https://base-mainnet.g.alchemy.com/v2/`,
    baseSepolia: `https://base-sepolia.g.alchemy.com/v2/`,
    optimismSepolia: `https://opt-sepolia.g.alchemy.com/v2/`,
    scroll: "https://rpc.scroll.io",
    localhost: "http://localhost:8545",
    sepolia: `https://eth-sepolia.g.alchemy.com/v2/`,
  };

  // Check if deployments directory exists
  if (!fs.existsSync(deploymentsDir)) {
    console.log("No deployments directory found. Run 'yarn deploy' first.");
    return;
  }

  // Read all chain deployment directories
  const chainDirs = fs
    .readdirSync(deploymentsDir)
    .filter(
      dir =>
        fs.statSync(path.join(deploymentsDir, dir)).isDirectory() &&
        fs.existsSync(path.join(deploymentsDir, dir, ".chainId")),
    );

  // Process each chain deployment
  for (const chainDir of chainDirs) {
    const chainId = fs.readFileSync(path.join(deploymentsDir, chainDir, ".chainId"), "utf8").trim();
    const chainName = chainIdToName[chainId] || chainDir;

    // Add chain configuration
    chains[chainName] = {
      chainId: Number(chainId),
      transport: chainRpcUrls[chainName],
    };

    // Check for ETHSplitter deployment
    const splitterPath = path.join(deploymentsDir, chainDir, "ETHSplitter.json");
    if (fs.existsSync(splitterPath)) {
      const deployment: DeploymentData = JSON.parse(fs.readFileSync(splitterPath, "utf8"));

      ethSplitterContracts[chainName] = {
        address: deployment.address as `0x${string}`,
        startBlock: deployment.receipt.blockNumber,
      };
    }
  }

  // Copy ETHSplitter ABI from artifacts
  const ethSplitterArtifact = path.join("./artifacts/contracts/Splitter.sol/ETHSplitter.json");

  if (fs.existsSync(ethSplitterArtifact)) {
    const artifact = JSON.parse(fs.readFileSync(ethSplitterArtifact, "utf8"));
    const abiContent = `// Auto-generated ABI for ETHSplitter
export const ETHSplitterAbi = ${JSON.stringify(artifact.abi, null, 2)} as const;`;
    fs.writeFileSync(path.join(ponderAbisPath, "ETHSplitter.ts"), abiContent);
  }

  // Generate the configuration file
  const configContent = `// This file is auto-generated by generatePonderConfig.ts
// Do not edit manually - changes will be overwritten

export const chainConfigs = {
  chains: ${JSON.stringify(chains, null, 2)},
  ethSplitterContracts: ${JSON.stringify(ethSplitterContracts, null, 2)
    .replace(/"address": "([^"]+)"/g, '"address": "$1" as `0x${string}`')
    .replace(/,\s*}/g, "}")},  
};
`;

  // Format with prettier
  const formattedConfig = await prettier.format(configContent, {
    parser: "typescript",
    printWidth: 100,
    singleQuote: false,
    trailingComma: "all",
  });

  fs.writeFileSync(ponderConfigPath, formattedConfig);

  // Create TypeScript configuration if it doesn't exist
  const ponderTsConfig = path.join(ponderPath, "tsconfig.json");
  if (!fs.existsSync(ponderTsConfig)) {
    const tsConfig = {
      compilerOptions: {
        target: "es2020",
        module: "esnext",
        lib: ["es2020"],
        moduleResolution: "bundler",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        allowSyntheticDefaultImports: true,
      },
      include: ["src/**/*", "ponder.config.ts", "ponder.schema.ts", "abis/**/*"],
      exclude: ["node_modules"],
    };

    fs.writeFileSync(ponderTsConfig, JSON.stringify(tsConfig, null, 2));
    console.log(`üìù Created tsconfig.json at ${ponderTsConfig}`);
  }

  // Create environment variables template
  const envPath = path.join(ponderPath, ".env.local");
  if (!fs.existsSync(envPath)) {
    const envContent = `# Database connection (optional - uses PGlite by default)
DATABASE_URL=

# RPC URLs for each chain - Add your Alchemy API keys
PONDER_RPC_URL_1=https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_137=https://polygon-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_42161=https://arb-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_10=https://opt-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_8453=https://base-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_84532=https://base-sepolia.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_11155420=https://optimism-sepolia.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_534352=https://rpc.scroll.io
PONDER_RPC_URL_31337=http://localhost:8545
PONDER_RPC_URL_11155111=https://eth-sepolia.g.alchemy.com/v2/YOUR_KEY
`;

    fs.writeFileSync(envPath, envContent);
    console.log(`üìù Created .env.local template at ${envPath}`);
  }

  // Create a sample Ponder configuration file
  const ponderConfigFile = path.join(ponderPath, "ponder.config.ts");
  if (!fs.existsSync(ponderConfigFile)) {
    const ponderConfigContent = `import { createConfig } from "@ponder/core";
import { http } from "viem";
import { chainConfigs } from "./src/config/chains";
import { ETHSplitterAbi } from "./abis/ETHSplitter";

export default createConfig({
  networks: Object.entries(chainConfigs.chains).reduce((acc, [chainName, config]) => {
    if (chainConfigs.ethSplitterContracts[chainName]) {
      acc[chainName] = {
        chainId: config.chainId,
        transport: http(process.env[\`PONDER_RPC_URL_\${config.chainId}\`] || config.transport),
      };
    }
    return acc;
  }, {} as any),
  contracts: {
    ETHSplitter: {
      abi: ETHSplitterAbi,
      address: chainConfigs.ethSplitterContracts,
      startBlock: Object.entries(chainConfigs.ethSplitterContracts).reduce((acc, [chainName, contract]) => {
        acc[chainName] = (contract as any).startBlock;
        return acc;
      }, {} as any),
    },
  },
});
`;

    const formattedPonderConfig = await prettier.format(ponderConfigContent, {
      parser: "typescript",
      printWidth: 100,
      singleQuote: false,
      trailingComma: "all",
    });

    fs.writeFileSync(ponderConfigFile, formattedPonderConfig);
    console.log(`üìù Created ponder.config.ts at ${ponderConfigFile}`);
  }

  // Create a sample Ponder schema file
  const ponderSchemaFile = path.join(ponderPath, "ponder.schema.ts");
  if (!fs.existsSync(ponderSchemaFile)) {
    const ponderSchemaContent = `import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  EthSplit: p.createTable({
    id: p.string(),
    sender: p.string(),
    totalAmount: p.bigint(),
    recipients: p.string().list(),
    amounts: p.bigint().list(),
    timestamp: p.bigint(),
    blockNumber: p.bigint(),
    transactionHash: p.string(),
  }),
  
  Erc20Split: p.createTable({
    id: p.string(),
    sender: p.string(),
    token: p.string(),
    totalAmount: p.bigint(),
    recipients: p.string().list(),
    amounts: p.bigint().list(),
    timestamp: p.bigint(),
    blockNumber: p.bigint(),
    transactionHash: p.string(),
  }),
  
  EthSplitEqual: p.createTable({
    id: p.string(),
    sender: p.string(),
    totalAmount: p.bigint(),
    recipients: p.string().list(),
    amountPerRecipient: p.bigint(),
    timestamp: p.bigint(),
    blockNumber: p.bigint(),
    transactionHash: p.string(),
  }),
  
  Erc20SplitEqual: p.createTable({
    id: p.string(),
    sender: p.string(),
    token: p.string(),
    totalAmount: p.bigint(),
    recipients: p.string().list(),
    amountPerRecipient: p.bigint(),
    timestamp: p.bigint(),
    blockNumber: p.bigint(),
    transactionHash: p.string(),
  }),
  
  Withdrawal: p.createTable({
    id: p.string(),
    owner: p.string(),
    token: p.string(),
    amount: p.bigint(),
    timestamp: p.bigint(),
    blockNumber: p.bigint(),
    transactionHash: p.string(),
  }),
}));
`;

    const formattedPonderSchema = await prettier.format(ponderSchemaContent, {
      parser: "typescript",
      printWidth: 100,
      singleQuote: false,
      trailingComma: "all",
    });

    fs.writeFileSync(ponderSchemaFile, formattedPonderSchema);
    console.log(`üìù Created ponder.schema.ts at ${ponderSchemaFile}`);
  }

  // Summary output
  console.log(`‚úÖ Generated Ponder config at ${ponderConfigPath}`);
  console.log(`‚úÖ Copied ABIs to ${ponderAbisPath}`);
  console.log(`‚úÖ Setup complete! Available chains: ${Object.keys(chains).join(", ")}`);

  if (Object.keys(ethSplitterContracts).length > 0) {
    console.log(`‚úÖ ETHSplitter deployed on: ${Object.keys(ethSplitterContracts).join(", ")}`);
  } else {
    console.log(`‚ö†Ô∏è  No ETHSplitter deployments found. Deploy the contract first.`);
  }
}

// Execute if run directly
if (require.main === module) {
  generatePonderConfig().catch(console.error);
}

export default generatePonderConfig;
